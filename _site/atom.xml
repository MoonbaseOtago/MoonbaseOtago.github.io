<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>VRoom!</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2021-11-20T14:54:08+13:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Paul Campbell</name>
   <email></email>
 </author>

 
 <entry>
   <title>Branch Target Cache [BTC] (part 3) Managing a speculative subroutine call stack</title>
   <link href="http://localhost:4000/2021/11/20/btc-part3/"/>
   <updated>2021-11-20T00:00:00+13:00</updated>
   <id>http://localhost:4000/2021/11/20/btc-part3</id>
   <content type="html">&lt;p&gt;This is the third of an occasional series of articles on the VRoom!/RVoom RISC-V 
CPU. This week a shorter update, we’re going to talk about how we can create speculative entries 
in the Branch Target Cache (BTC) call-return stack. A quick reminder of some of what we learned in the previous blog.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we decode large bundles of many instructions every clock&lt;/li&gt;
  &lt;li&gt;we predict bundles not instructions&lt;/li&gt;
  &lt;li&gt;we maintain a queue of pending uncommitted BTC predictions&lt;/li&gt;
  &lt;li&gt;each entry overrides the ones after it and the main tables&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Last time we talked about how we manage speculated branch target cache (BTC) entries, in short
we have a queue of speculated BTC updates in front of the normal BTC tables, those entries are
discarded or updated when a speculated branch is found to have been mispredicted, and retired into the
main tables when a corresponding branch (or rather bundle of instructions) is committed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/btc-queue.svg&quot; alt=&quot;placeholder&quot; title=&quot;Branch Target Cache example&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;subroutine-call-stack&quot;&gt;Subroutine call stack&lt;/h3&gt;

&lt;p&gt;In addition to the standard BTC tables we also have a per-access mode call-return stack,
RISC-V defines for us the instructions that should be used to infer these (and which not to),
in the BTC we provide a 32-entry stack (smaller for M-mode) of the last 32 subroutine calls
so we can predict the return address when decoding ret instructions (if we get it wrong it’s
not the end of the world, it will be corrected when the ret instruction hits the branch ALU)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;public/images/stack.svg&quot; width=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Initially we thought we’d just tag branches with a pointer to the top-of stack, and wind it back when we got
a misprediction, then we found out a case which turned out to have a particularly heavy impact on performance:&lt;/p&gt;

&lt;pre&gt;

	.....
	call	a
r1:	call	b
r2	....

a:	bnez	a0, 1f		&amp;lt; branch mispredicted
	ret
1:	....

b:	....

&lt;/pre&gt;

&lt;p&gt;essentially what happens here is that we speculatively fetch the following instruction stream:&lt;/p&gt;

&lt;pre&gt;
	Instruction		call stack
	===========		==========
				

	call	a		r1 -
	bnez 	a0, 1f		r1 -	&amp;lt; remembers TOS
	ret			-	&amp;lt; everything from here on is 
	call	b		r2 -	  mispredicted
	....				

&lt;/pre&gt;

&lt;p&gt;Sometime later the bnez is resolved in the branch ALU and discovered to have been mispredicted. But by that point
the return address ‘r1’ on the call stack has been popped and replaced with ‘r2’, even though we got the top of stack (TOS)
correct, its contents are wrong, and can’t be undone when we discover the misprediction.
This means that at some later time when we finally do return from subroutine ‘a’
the prediction will be to ‘r2’ rather than ‘r1’ - this in turn will result in another misprediction when that return
instruction hits the branch ALU, which is exactly what were were trying to avoid.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Our solution is to take a similar approach to the one we took for the BTC tables and put a queue of prediction
history in front of the call/return stack, in this case it’s a queue of push and pop 
actions. Instead of being indexed by hashes of the PC/global history, it’s simply the TOS address that’s used instead.
Top of stack always returns the latest push that matches the current TOS (and the top of the actual backing stack otherwise).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;public/images/stack-queue.svg&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Like BTC speculative queue mentioned in the previous blog entry this queue is managed by the same bundle tag we
attach to instructions in the commitQ - when a mispredicted branch instruction is discovered then the
return stack speculative queue is truncated removing entries that correspond to the discarded instruction bundles
and the TOS updated to the oldest retained entry.&lt;/p&gt;

&lt;p&gt;Similarly when the last instruction in an instruction bundle is committed then related  call-return stack
speculative queue entries are
tagged ‘committed’, and then written back in order into the call-return stack.&lt;/p&gt;

&lt;h3 id=&quot;to-recap&quot;&gt;To Recap&lt;/h3&gt;
&lt;p&gt;The important ideas here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we have call-return stacks to predict the address of return instructions&lt;/li&gt;
  &lt;li&gt;we maintain a queue of speculative push/pop transitions&lt;/li&gt;
  &lt;li&gt;each entry overrides the ones after it and the main tables&lt;/li&gt;
  &lt;li&gt;the queue is flushed on a misprediction&lt;/li&gt;
  &lt;li&gt;committed data is pushed into the main tables&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next time: How our main pipe works - an overview&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Branch Target Cache [BTC] (part 2) Living in a Speculative World</title>
   <link href="http://localhost:4000/2021/11/14/btc-part2/"/>
   <updated>2021-11-14T00:00:00+13:00</updated>
   <id>http://localhost:4000/2021/11/14/btc-part2</id>
   <content type="html">&lt;p&gt;This is the second of an occasional series of articles on the VRoom!/RVoom RISC-V 
CPU. This week we’re going to talk about how we can create speculative entries 
in the Branch Target Cache (BTC). A quick reminder of some of what we learned in the previous blog.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we decode large bundles of many instructions every clock&lt;/li&gt;
  &lt;li&gt;we predict bundles not instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;system-architecture&quot;&gt;System Architecture&lt;/h3&gt;

&lt;p&gt;Let’s have a look at an overview of our system architecture:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/talk/assets/overview.svg&quot; alt=&quot;placeholder&quot; title=&quot;System Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Instructions are fetched from the instruction cache (I$1), decoded, renamed to commit registers and entered
into the commitQ. Once in the commitQ instructions can be executed in any order and even after they are
executed they can be discarded by a trap or a preceding mispredicted branch.&lt;/p&gt;

&lt;p&gt;At the end of the commitQ are committed instructions, when they and all instructions before them are done, all
branches are correctly predicted, there are no pending traps, then the CPU will retire up to the last 8 
committed instructions per clock.&lt;/p&gt;

&lt;h3 id=&quot;btc-operations&quot;&gt;BTC Operations&lt;/h3&gt;

&lt;p&gt;Our BTC contains tables that are accessed using hashes constructed from the program counter (PC) and a
global history. On a traditional system the BTC tables and global history would be updated on every 
clock, In VROOM! we can have many instructions outstanding, often they are speculative instructions
that may never be committed - when a branch instruction is processed by the branch ALU and is discovered to have been
speculated incorrectly it can trigger
the discard of subsequent speculative instructions (including other branch instructions), branch instructions can
also be processed out of order.&lt;/p&gt;

&lt;p&gt;Processing branch instructions is important, we want to use branch mis-predictions to update the BTC tables - if
we assumed that a branch would be taken and it wasn’t we need to back out and change the value that we had 
previously set them too.&lt;/p&gt;

&lt;p&gt;A simple solution (and the one that we originally tried) was to wait until the commit stage of the CPU
and then only use instructions that have been committed (and branches that have been resolved) to update the BTC tables.
It works, but it’s very slow to update (remember that a big version of our CPU can have ~150 instructions in flight at
once). Consider something like this:&lt;/p&gt;

&lt;pre&gt;
clear:
1:	std	x0, (a0)
	add	a0, a0, 8
	add	a1, a1, -1
	bnez	a1, 1b
	ret
&lt;/pre&gt;

&lt;p&gt;The core of this is a single decode-bundle that always loops and contains 4 instruction in its core.
The CPU may push 150/4 = 30+ bundles, 30 times around the loop, before we can start updating the
BTC - this is particularly a problem with global history predictors which to be useful really to be updated 
on every prediction.&lt;/p&gt;

&lt;h3 id=&quot;a-better-solution&quot;&gt;A better solution&lt;/h3&gt;

&lt;p&gt;Let’s look at how our BTC works:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/btc.svg&quot; alt=&quot;placeholder&quot; title=&quot;Branch Target Cache example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The PC and the global history (a bit vector) are hashed (just some xors and bit swapping) into indexes into the 3
BTC tables, they’re used to look up the 3 tables. The combined output is used to choose whether the bimodal or
global history predictor is best for a particular bundle.&lt;/p&gt;

&lt;p&gt;Our solution to the above problems is to create a ‘pending prediction’ queue in front of the normal BTC tables. Each
entry contains the information about a bundle prediction. Including the PC used for it and the global history at the
point that it was created.
Newer predictions are performed by looking into the queue from
most recent to oldest for each of the 3 hashes (individually and independently) comparing them with the hashes of the
PC and global history generated in each entry, if no match is found then the value from the main tables is used.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/btc-queue.svg&quot; alt=&quot;placeholder&quot; title=&quot;Branch Target Cache example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The per-bundle BTC pending prediction queue acts similarly to the main per-instruction commitQ - in this case
each instruction in the commitQ carries a reference to the decode-bundle it came from.&lt;/p&gt;

&lt;h3 id=&quot;actions&quot;&gt;Actions&lt;/h3&gt;

&lt;p&gt;If a branch instruction in the commitQ is discovered to be mispredicted
all the instructions following it are discarded. At the same time entries in the BTC
prediction queue that are newer than the bundle corresponding to  the mispredicted instruction are also discarded, and the
prediction queue entry that does correspond to the mispredicted branch has its data updated. Finally that prediction queue’s
copy of the global history along with the new branch information is used to reload the global history
vector used for the next BTC prediction.&lt;/p&gt;

&lt;p&gt;Finally each BTC pending queue entry has a ‘committed’ bit - it gets set when all the instructions in the corresponding
bundle hit the commit state in the commitQ, that means none of them will be mispredicted, or already have been.
On every clock if the oldest entry in the BTC pending queue has its committed bit set then its data is copied back into the main BTC tables.&lt;/p&gt;

&lt;h3 id=&quot;to-recap&quot;&gt;To Recap&lt;/h3&gt;
&lt;p&gt;The important ideas here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;we maintain a queue of pending uncommitted BTC predictions&lt;/li&gt;
  &lt;li&gt;each entry overrides the ones after it and the main tables&lt;/li&gt;
  &lt;li&gt;the queue is flushed and the top entry updated on a misprediction&lt;/li&gt;
  &lt;li&gt;committed data is pushed into the main tables&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next time: BTC (Part 3) Predicting Subroutine Returns&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Introducing Vroom!</title>
   <link href="http://localhost:4000/2021/11/06/introducing-vroom/"/>
   <updated>2021-11-06T00:00:00+13:00</updated>
   <id>http://localhost:4000/2021/11/06/introducing-vroom</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/talk/assets/chip.png&quot; alt=&quot;placeholder&quot; title=&quot;Branch Target Cache example&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;executive-summary&quot;&gt;Executive Summary&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Very high end RISC-V implementation – goal cloud server class&lt;/li&gt;
  &lt;li&gt;Out of order, super scalar, speculative&lt;/li&gt;
  &lt;li&gt;RV64-IMAFDCHB(V)&lt;/li&gt;
  &lt;li&gt;Up to 8 IPC (instructions per clock) peak, goal ~4 average on ALU heavy work&lt;/li&gt;
  &lt;li&gt;2-way simultaneous multithreading capable&lt;/li&gt;
  &lt;li&gt;Multi-core&lt;/li&gt;
  &lt;li&gt;Early (low) dhrystone numbers: ~3.6 DMips/MHz - still a work in progress. Goal ~4-5&lt;/li&gt;
  &lt;li&gt;Currently boots Linux on an AWS-FPGA instance&lt;/li&gt;
  &lt;li&gt;GPL3 – dual licensing possible&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;downloads&quot;&gt;Downloads&lt;/h3&gt;

&lt;p&gt;VRoom! is hosted with GitHub. Head to the &lt;a href=&quot;https://github.com/MoonbaseOtago/vroom&quot;&gt;GitHub repository&lt;/a&gt; for downloads.&lt;/p&gt;

&lt;h3 id=&quot;licensing&quot;&gt;Licensing&lt;/h3&gt;

&lt;p&gt;VRoom! is currently licensed GPL3. We recognize that for many reasons one cannot practically build a large GPL3d chip 
design - VRoom! is also available to be commercial licensed.&lt;/p&gt;

</content>
 </entry>
 

</feed>
